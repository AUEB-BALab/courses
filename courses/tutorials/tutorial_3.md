<img src="media/AUEB_logo.jpg" width="425" /> <img src="media/BA_Lab.png" width="425" />
# Προγραμματισμός ΙΙ
## Κανόνες μορφοποιήσης

* [Στέφανος Γεωργίου](https://www.balab.aueb.gr/stefanos-georgiou.html)
* [Θεόδωρος Στασσινόπουλος](https://www.balab.aueb.gr/theodore-stassinopoulos.html)


## Αντικειμενοστραφής Προγραμματισμός

* Είναι τύπος προγραμματισμού βασισμένος σε αντικείμενα (objects) που μοντελοποιούν
τα δεδομένα με βάση την εσωτερική τους κατάσταση (state) και με βάση τη συμπεριφορά
τους (behaviour).

```java
public class LightBulb {

    private static int numOfObjects = 0;
    private boolean light;

    public LightBulb(boolean light) {
        this.light = light;
        numOfObjects++;
    }

    public boolean isLit() {
        return light;
    }

    public void switchLight() {
        light = !light;
    }

    public static int getNumOfObjects() {
        return numOfObjects;
    }
}
```


## Αντικειμενοστραφής Προγραμματισμός (2)

* Ένα αντικείμενο αποτελείται από κανένα ή περισσότερα πεδία/ιδιότητες που καθορίζουν την
κατάστασή του και απο καμία ή περισσότερες μεθόδους που καθορίζουν τη συμπεριφορά
του.
* Κάθε αντικείμενο είναι στιγμιότυπο μιας κλάσης που καθορίζει και τον τύπο του.
* Κάθε κλάση είναι ένα προσχέδιο (blueprint) ή πρότυπο (prototype) για τη
δημιουργία αντικειμένων.
* Ένα αντικειμενοστραφές πρόγραμμα αποτελεί μια συλλογή από αντικείμενα που
αλληλεπιδρούν μεταξύ τους.


## Κατασκευαστής

* Ο κατασκευαστής (constructor) είναι μια ειδική μέθοδος η οποία:
* Έχει πάντα το ίδιο όνομα με την κλάση που βρίσκεται
* Στη σύνταξή του δε δηλώνεται κάποιος τύπος επιστροφής ούτε void.
* Μπορεί να δεχθεί ορίσματα.
* Καλείται μέσω του τελεστή new είναι υπεύθυνος για τη δημιουργία κάποιου
αντικειμένου προσδίδοντάς του ενδεχομένως και κάποιες τιμές στα πεδία του.
* Ο κατασκευαστής είτε θα ορίστει από τον προγραμματιστή είτε θα χρησιμοποίηθει
ένας εγγενής κατασκευαστής που δεν αρχικοποιεί κανένα πεδίο. Σε κάθε περίπτωση
κάθε κλάση έχει (τουλάχιστον ένα) κατασκευαστή.


## Διεύθυνση Αντικειμένων στη Μνήμη

* Η 'new' πέρα από το ότι καλεί τον κατασκευαστή μιας κλάσης φροντίζει επίσης τη
δέσμευση αναγκαίας μνήμης για το αντικείμενο που θα δημιουργηθεί.

Παράδειγμα:
```java
LightBulb lightBulb = new LightBulb(false);
```

* Η μεταβλητη του object (η lightBulb στο παράδειγμα) δεν περιέχει την πληροφορία της κατάστασής του
αλλά έναν αριθμό (σε δεκαεξαδικό σύστημα) που είναι η διεύθυνση στη μνήμη που βρίσκεται το object. (Δοκιμάστε να κάνετε
print ένα object).


## Στατικά και μη στατικά πεδία και μέθοδοι.

* Ένα στατικό πεδίο σε μια κλάση είναι ένα κοινό πεδίο με συγκεκριμένη κατάσταση
για όλα τα αντικείμενα που έχουν τύπο αυτή την κλάση. Με άλλα λόγια τα
αντικείμενα μιας κλάσης μοιράζονται ένα αντίγραφο αυτού του πεδίου.
* Μια στατική μέθοδος μπορεί να κληθεί χωρίς να δημιουργηθεί κάποιο
αντικείμενο απαραιτητα. Μια τέτοια μέθοδος έχει πρόσβαση μόνο σε στατικά πεδία
* Ένα μη στατικό πεδίο είναι ένα πεδίο όπου κάθε ξεχωριστό αντικείμενο εχει το
δικό του αντίγραφο. Συνεπώς μια μεταβολή της κατάστασης του από ένα αντικείμενο
δε θα επιρρεάσει το αντίστοιχο πεδίο σε κάποιο άλλο αντικείμενο (της ίδιας κλάσης).
* Οι μη στατικές μέθοδοι μπορούν να κληθούν μόνο από στιγμιότυπα μιας κλάσης
και έχουν πρόσβαση και σε στατικά και σε μη στατικά πεδία.



## Προσδιοριστές Πρόσβασης

* Οι προσδιοριστές πρόσβασης χρησιμοποιούνται προθεματικά για να καθορίσουν την πρόσβαση σε
μια μεταβλητή, μια μέθοδο ή μια κλάση απο κάποια άλλη πηγή. Οι προσδιοριστές στη java είναι οι εξής:
* public: Κλάσεις, μέθοδοι ή πεδία είναι προσβάσιμα χωρίς κανένα περιορισμό.
* protected: Κλάσεις, μέθοδοι ή πεδία είναι προσβάσιμα απο παραγώμενες κλάσεις
(σε επόμενο μάθημα) και από κλάσεις του ίδιου πακέτου.
* (default): Κλάσεις, μέθοδοι ή πεδία είναι προσβάσιμα μόνο από κλάσεις του ίδιου
πακέτου.
* private: Κλάσεις, μέθοδοι ή πεδία είναι προσβάσιμα μόνο από το εσωτερικό της ίδιας
της κλάσεις που υπάρχουν.


## O προσδιοριστής 'final'

* Μεταβλητές που χρησιμοποιούν προθεματικά το 'final' στον ορισμό τους, αν πάρουν κάποια τιμή
τότε αυτή δεν μπορεί να αλλάξει (γίνεται σταθερά).
* Μέθοδοι που χρησιμοποιούν προθεματικά το 'final' στον ορισμό τους δεν μπορούν
να γίνουν override απο παραγώμενες κλάσεις (σε επόμενο μάθημα).
* Κλάσεις που χρησιμοποιούν προθεματικά το 'final' στον ορισμό τους δεν μπορούν
να επεκταθούν απο άλλες κλάσεις.


## Παράδειγμα(1)

```java
public class Test {

    public static void main(String[] args) {
        LightBulb objLightBulb1 = new LightBulb(true);
        LightBulb objLightBulb2 = new LightBulb(true);

        objLightBulb1.setState();

        System.out.println(objLightBulb1);
        System.out.println(objLightBulb2);
    }
}
```


## Παράδειγμα(2)

```java
public class Test {

    public static void main(String[] args) {
        LightBulb objLightBulb1 = new LightBulb(true);
        Foo objLightBulb2 = objLightBulb1;

        objLightBulb1.switchlight();

        System.out.println(objLightBulb1);
        System.out.println(objLightBulb2);
    }
}
```


## Παράδειγμα(3)

```java
public class Test {

    public static void main(String[] args) {
        LightBulb objLightBulb1 = new LightBulb(true);
        LightBulb objLightBulb2 = new LightBulb(false);
        System.out.println(LightBulb.getNumOfObjects());
        System.out.println(objLightBulb1.getNumOfObjects());
        System.out.println(objLightBulb1.isLit());

        // System.out.println(LightBulb.isLit());
        // System.out.println(lightBulb.light);
    }
}
```


## Άσκηση

* Τι θα εκτυπωθεί στα δύο προηγούμενα κομμάτια κώδικα; Μπορείτε να αιτιολογησετε
το αποτέλεσμα;
